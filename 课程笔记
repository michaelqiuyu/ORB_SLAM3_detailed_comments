一、计算机视觉life课程笔记：
	1. ORB-SLAM3简介
		1.1 ORB-SLAM3量化对比：双目+IMU 》 单目+IMU 》双目

		1.2 数据关联：
			1.2.1 短期数据关联：仅仅和最短几秒内获取的地图元素进行匹配，这是大多数视觉里程计使用的唯一数据关联类型，这种方法存在的问题是：一旦地图元素从视野中消失，就会被丢弃，即使回到原来的地方，也会造成持续的估计漂移。对应ORB-SLAM里的跟踪。
			1.2.2 中期数据关联：匹配距离相机近并且累计漂移较小的地图元素。与短期观测相比，这些信息可以一并加入到BA优化，精度更高的关键所在。对应ORB-SLAM里的局部建图。
			1.2.3 长期数据关联：使用位置识别技术将观测与之前访问过的区域中的元素匹配，不管是在闭环检测中的累计漂移，还是跟踪丢失、重定位的情况下都可以成功匹配。长期匹配允许使用位姿图优化来重置漂移和矫正回环。这是保证中、大型闭环场景中SLAM局部较高精度的关键。对应ORB-SLAM里用词袋进行闭环和重定位。
			1.2.4 多地图数据关联：可以使用之前已经建立的多块地图来实现地图中的匹配和BA优化

		1.3 ORB-SLAM3运行
			1.3.1 在封闭场景，推荐使用ORB系列
			1.3.2 在自动驾驶场景，视觉不会是主要信息来源，视觉不稳定，也基本不会有回环，适合小而美的系统，如VINS系列


	2. ORB-SLAM2回顾
		2.1 有关特征点方向的说明：
			2.1.1 对每一个特征点都可以计算其质心，从而得到方向；从人的角度将，方向始终是没有变化的，但是在不同的视角下，建立的图片坐标系是不同的，因此同一个方向在不同坐标系下得到的方向是不同的，同一个特征点在两个视角下的角度的不同近似表达了两个视角之间的旋转；因此匹配的时候使用角度的一致性检验，保留三个峰值直方图对应的匹配
			2.1.2 注意，一般我们会将两幅图的特征点相连，来观察匹配的正确性，这个时候不用过分关注连线之间是否平行，即使不平行也不能说明匹配是错误的，这是视觉上很容易犯错的，我们还是应该关注匹配的角度差值是否在峰值的直方图中
			2.1.3 在代码中，只有在匹配要求很高或者匹配的不确定性高的时候，才会使用角度一致性检验；
				1. 初始化匹配的时候，要求匹配的正确性非常高，这会显著影响地图的最终精度 
				2. 词袋的匹配的时候，词袋匹配的不确定性较大
				3. 位姿并不准确的投影匹配，如恒速模型得到的位姿、重定位poseoptimize之后内点数量不够（也就是位姿不太准）进行的投影匹配


	3. IMU原理介绍：请参考邱笑晨的IMU笔记《邱笑晨:预积分总结与公式推导20180827》
		3.1 传感器介绍：
			传感器类型          优点               缺点
				轮速			精度高一些	       二维数据
				GPS		  直接输出绝对位置        精度差
				IMU      频率高、短时精度好    无绝对信息、累计误差大


	4. IMU预积分在ORB-SLAM3中的实现：重力始终设置为g(0, 0, -1)，注意正负号
		4.1 IMU初始化：三阶段初始化的函数名（InitializeIMU）都是一样的，只是参数不一样而已
			4.1.1 IMU初始化的目的：获取重力在当前世界系的方向，当然后面是改变世界系的方向，使得重力方向为Z轴负向
				  IMU初始化的参数设置：priorG、priorA、bFirst；前两者为零偏的权重，后者三次初始化的值都一样，用于判断是否进行FullInertialBA

			4.1.2 第一阶段初始化：
				1. 判断条件：惯性模式，但是还没有初始化；单目和非单目的阈值priorA不同（单目1e10，非单目1e5）
				2. 获取距离第一个关键帧一定的时间且地图中有一定数量的关键帧
				3. 根据Ri * △Vij = Vj - Vi - g * △tij，注意这里的世界系的Z轴为g的负向，与当前视觉的世界系不一样。
					3.1 首先将世界系修改为当前视觉的世界系，也就是Ri' * △Vij = sVj' - sVi' - Rwg * g * △tij，其中Vi和Vj根据视觉进行计算
					3.2 mOwb1 = Rwc1 * tcb + stwc1, mOwb2 = Rwc2 * tcb + stwc2, 从而mOwb2 - mOwb1 = Rwc2 * tcb - Rwc1 * tcb + stwc2 - stwc1，在这里认为Rwc1和Rwc2近似相等（连续两个关键帧的旋转确实比较接近，而且后面还会做尺度和重力的refine），因此有mOwb2 - mOwb1 = s(twc2 - twc1)，否则mOwb2 - mOwb1的结果的尺度是模糊的，也就是一部分有尺度，一部分没有尺度。据此计算速度
					3.3 令i = j - 1，对j进行递增求和，得到dirG = Rwg * g * sum_t - sVn，忽略sVn，就形成了y = Rx计算R的形式，据此计算Rwg的初始值：通过x和y计算旋转轴，然后计算旋转角，然后计算轴角，得到旋转矩阵
					3.4 此处忽略Vn的影响导致求得的R必然是不准确的，而且这种不准确与Vn的大小密切相关；仅能作为初值用于后面对R的精确化求解
					3.5 s是一个待求的常数，Vn是速度，不是一个剧烈波动的数，因此sVn是一个稳定的数值，时间越长，n*Rwg*g*t在dirG中所占的比重越大，近似的准确性也就越高，因此，对have_imu_num以及关键帧数量和时间有要求
					3.6 计算mTinit = 当前关键帧的时间戳 - 第一个没有prev关键帧的关键帧的时间戳
					3.6 第一阶段初始化成功后，后续进入到InitializeIMU函数，Rwg的初始值为单位阵，零偏使用之前优化的结果
				4. 不利用速度或者位移来计算Rwg的原因，以下以速度来做说明：
					4.1 根据相机位姿计算速度V1，如Eigen::Vector3f _vel = ((*itKF)->GetImuPosition() - (*itKF)->mPrevKF->GetImuPosition())/(*itKF)->mpImuPreintegrated->dT;
                    4.2 根据IMU预积分递推得到对应时刻的速度V2
                    4.3 那么上面两个速度分别是在世界系W和g下获得的，据此可以得到Rwg
                    4.4 V2实际上不可求，因为IMU递推的初值旋转不可知，因为IMU递推默认世界系g的Z轴为重力反向，因此初始旋转并不是单位阵
                    4.5 因此，此处使用相同方法的位姿，也无法获取Rwg
				5. InertialOptimization优化：
					5.1 构建的边有8个顶点，其中VP1、VV1、VP2、VV2是时变的，VG、VA、VGDir、VS是时不变的（也就是只建立一个顶点）
					5.2 注意这里的预积分项与邱笑晨文档的预积分项是不同的，因此求解的雅克比也是不同的（变化很小）
					5.3 对重力的处理：由于一直重力方向g=(0, 0, -1)，因此Rwg对应的轴角的形式为(a, b, 0)，为2自由度
					5.4 一定要明确预积分量与世界系的选择无关，相关推导见代码和邱笑晨文档，这也是能够这样进行预积分初始化的原因
					5.5 关于尺度的更新预计定义不同，应该是一个bug
					5.6 由于priorA的不同，LM算法的lambda也不同
					5.7 优化结束后，设置关键帧的零偏、速度；注意，位姿是不更新的
				6. ApplyScaledRotation：单目视觉基于一个未知尺度构建，得到尺度s后，应用s；变换世界系
					6.1 变换世界系，将世界系变换为重力方向为Z轴负向
					6.2 更新每一帧的位姿：平移的尺度，世界系变化导致的位姿变化，每一帧速度的尺度和坐标系变化
					6.3 地图点的尺度和世界系变化引起的变化
				7. UpdateFrameIMU
					7.1 更新mlRelativeFramePoses的尺度，Frame的位姿由此计算
					7.2 更新mLastBias，并设置mpLastKeyFrame，更新上一帧和当前帧的零偏
					7.3 更新上一帧的SetImuPoseVelocity：速度、依据Tbw计算的Tcw，相机光心等
					7.4 更新当前帧的SetImuPoseVelocity：速度、依据Tbw计算的Tcw，相机光心等
					7.5 mnFirstImuFrameId = mCurrentFrame.mnId;
					7.6 实际上，一般不直接使用Frame的位姿，一般都是基于其参考关键帧来计算位姿，这里计算得到的位姿，不一定使用了
				8. 对每一帧关键帧，标记bImu = true；注意，此步骤只在第一阶段初始化中有
				9. 设置地图初始化成功，以及相关变量
				10. 视觉惯性联合优化；bFirst为true，执行Optimizer::FullInertialBA(mpAtlas->GetCurrentMap(), 100, false, mpCurrentKeyFrame->mnId, NULL, true, priorG, priorA);注意第三阶段的参数不同
					10.1 第一、第二阶段只会建立一个零偏顶点，第三阶段会根据每一个关键帧建立一个零偏的顶点
					10.2 第一、第二阶段对零偏的约束是一元边，将零偏约束在0附近；第三阶段是二元边，也就是前后两帧两帧的零偏需要接近
					10.3 添加视觉边，区分左右目和双目，双目情况下，都是重投影误差，边的数量会多于左右目
					10.4 保存优化后的结果，为后面更新做准备
				11. 处理新进来的关键帧
				12. 从地图的初始关键帧开始，更新关键帧的位姿、速度、零偏；使用了扩展树，计算过程使用了是否参与了10的优化
				13. 对地图的所有地图点进行更新，计算过程使用了是否参与了10的优化，基于参考关键帧进行更新

			4.1.3 第二阶段初始化：mTinit小于100s，并且处于惯性模式
				1. 判断条件：第一阶段初始化成功，跟踪正常，还没有进行VIBA1，mTinit大于5s；单目非单目的阈值一致（但是使用了if语句进行判断）
				2. 设定Rwg的初始值为单位阵，零偏使用之前优化的结果
				3. 执行第一阶段初始化的步骤5~7、9~13
				4. 经历一定的时间（mTinit大于5s）再执行，此时时间还不是很久，可以只使用一个零偏

			4.1.4 第三阶段初始化：mTinit小于100s，并且处于惯性模式
				1. 判断条件：第一阶段初始化成功，跟踪正常，还没有进行VIBA2，mTinit大于15s；单目非单目的阈值一致（但是使用了if语句进行判断）
				2. Rwg的初始值为单位阵，零偏使用之前优化的结果
				3. 执行第一阶段初始化的步骤5~7、9~13
				4. 经历一定的时间（mTinit大于15s）再执行，此时时间已经比较久了，不再适合只使用一个零偏了


		4.2 尺度重力方向优化：距离IMU第一阶段初始化成功累计时间小于100s，并且处于惯性模式，累计关键帧数量不超过200帧
			4.2.1 距离IMU第一阶段初始化成功累计时间在25~25.5、35~35.5、45~45.5、55~55.5、65~65.5、75~75.5；并且是单目的时候执行
			4.2.2 ScaleRefinement
				1. 设置Rwg为单位阵，尺度为1，执行InertialOptimization，优化重力和尺度
				2. InertialOptimization
					2.1 构建的边有8个顶点，其中VP1、VV1、VP2、VV2、VG、VA固定不变，VGDir、VS为优化的状态量
					2.2 获得优化结果
				3. 执行ApplyScaledRotation，与上面相同
				4. 执行UpdateFrameIMU，与上面相同
				5. 优化的这段时间进来的关键帧，全部删除不要，清空mlNewKeyFrames

	5. 跟踪线程
		5.1 如果局部建图线程认为IMU有问题，就ResetActiveMap：重置当前活跃地图，不保存当前地图
		5.2 mState != NO_IMAGES_YET
			5.2.1 如果上一帧的时间戳大于当前帧的时间戳，那么就CreateMapInAtlas（保存当前地图，并创建一个新地图）
			5.2.2 如果当前帧的时间戳>上一帧时间戳+1，那么仅处理惯性模式
				1. 如果已经经过了第一阶段初始化
					1.1 固脱没有完成第三阶段初始化，那么ResetActiveMap
					1.2 否则，保存当前地图，并创建一个新地图CreateMapInAtlas
				2. 否则，直接ResetActiveMap

		5.3 如果是IMU模式下，就将上一关键帧的零偏赋值为当前帧

		5.4 如果没有图像，就将状态mState设置为NOT_INITIALIZED

		5.5 在IMU模式下，并且mbCreatedMap=False的时候，进行IMU预积分
			5.5.1 对mbCreatedMap的阐述：
				1. 创建地图的时候CreateMapInAtlas，mbCreatedMap=True，这个含义应该是刚刚创建地图，还没有图片信息，自然不需要预积分
				2. 一旦有图片进来后，mbCreatedMap=false，这个时候就需要预积分了
			5.5.2 PreintegrateIMU
				1. 通过插值计算两帧之间的IMU测量值信息
				2. 对上一帧执行IMU预积分计算，对上一关键帧执行预积分计算，注意pImuPreintegratedFromLastFrame为新建的局部变量，mpImuPreintegratedFromLastKF为Track的成员变量，并对当前帧的mpImuPreintegratedFrame、mpImuPreintegrated和mpLastKeyFrame进行赋值
				3. 设置当前帧的预积分结束

		5.6 初始化
			5.6.1 单目初始化MonocularInitialization
				1. mbReadyToInitializate为false
					1.1 如果当前帧的特征点的数目>100，设置相关变量，如给mpImuPreintegratedFromLastKF、mCurrentFrame.mpImuPreintegrated赋值，并设置mbReadyToInitializate为true
				2. 否则（第二帧来了）
					2.1 条件1：特征点的数目<100；条件二：IMU模式，上一帧时间戳-初始帧时间戳>1；条件1/2只要满足其一，那么mbReadyToInitializate设置为false，并直接结束
					2.2 两帧之间构建匹配，匹配的方法是窗口匹配（认为两帧比较接近，直接画圈搜索），匹配数量<100，那么mbReadyToInitializate设置为false，并直接结束；否则，执行2.3
					2.3 两帧重建：ReconstructWithTwoViews
						2.3.1 相机模型
							1. 针孔相机：执行Reconstruct
							2. 鱼眼相机：对特征点去畸变、执行Reconstruct；注意，鱼眼相机仅仅在初始化阶段执行去畸变，其他时候都是带着畸变进行处理
						2.3.2 Reconstruct
							1. 迭代创建最小集（8点法）
							2. 多线程计算F和H，并计算得分，据此获得最优的几何模型
							3. 从F或者H中分解出R和t
					2.4 两帧重建成功，就执行CreateInitialMapMonocular
						2.4.1 设置地图最开始的两个关键帧，如果是IMU模式，就设置第一个关键帧的mpImuPreintegrated为NULL
						2.4.2 对两个关键帧计算词袋、插入地图、设置地图点
						2.4.3 更新两帧之间的连接UpdateConnections，并设置尺度，并据此尺度，修改地图点和位姿
						2.4.4 其他的一些必要操作，并设置mState为OK

			5.6.2 双目/RGBD初始化StereoInitialization
				1. 特征点的数目>500，否则，直接结束
				2. 如果是IMU模式
					1. 如果当前帧或者前一帧的mpImuPreintegrated为NULL，那么直接结束，也就是第一和第二帧不执行初始化
					2. 如果非快速IMU初始化，并且当前帧的预积分的平均加速度-上一帧的预积分的平均加速度的模长<0.5，表示没有足够的加速度，直接结束
					3. 如果mpImuPreintegratedFromLastKF不为NULL，就delete并重新new，并将其赋值给当前帧的mpImuPreintegrated
				3. 如果是IMU模式，就是值当前帧的R、t、v，注意世界系为相机系，设置的是IMU的信息；否则，直接设置当前帧的位姿为单位阵
				4. 设置当前帧为第一个关键帧，并将其添加到地图中
				5. 如果是双目模式：对深度值为正的特征点，取出mvDepth中的值并构建地图点，并添加到地图中
				6. 如果是左右目模式：取出mvStereo3Dpoints中的地图点，并构建地图点，并添加到地图中，注意，这里一个地图点在mvpMapPoints存储了两次，但是下标是不同的
				7. 其他的一些必要的操作，并设置mState为OK

			5.6.3 如果初始化失败，就将上一帧设置为当前帧，并直接结束；否则，如果当前地图是Atlas地图中的第一个子地图，那么就设置mnFirstFrameId为当前帧的mnId

		5.7 跟踪模式
			5.7.1 正常的SLAM模式
				1. mstate == OK:
					1.1 CheckReplacedInLastFram:检查上一帧中是否有点需要地图点在局部建图线程中被替换，如果发生替换，就将上一帧的地图点也对应替换，注意，这也是局部建图线程没有直接删除这些被替换的地图点的原因，如果在局部建图线程中被删除，那么上一帧中需要被替换的地图点也就被删除了，也就没办法执行替换操作了
					
					1.2 条件1：没有速度且没有imu初始化；条件2：刚刚重定位成功；如果条件1或者条件2满足，那么就执行参考关键帧跟踪TrackReferenceKeyFrame：
						1.2.1 TrackReferenceKeyFrame:
							1. 将当前帧与参考关键帧做词袋匹配，如果匹配数量少于15，那么直接结束，认为跟踪失败，否则
							2. 将匹配的地图点赋值给当前帧，并设置当前帧的位姿为上一帧的位姿，然后执行PoseOptimization（仅优化位姿，不优化地图点）
							3. 剔除BA过程中标记的外点，并统计内点的数目
							4. 如果在IMU模式下，直接认为跟踪成功；否则如果内点数目不少于10个才认为跟踪成功，否则，认为失败
					
					1.3 如果条件1和条件2都不满足，那么执行恒速模型跟踪TrackWithMotionModel，如果恒速模型跟踪失败，那么执行TrackReferenceKeyFrame
						1.3.1 TrackWithMotionModel：
							1. UpdateLastFrame：
								1.1 获取上一帧的参考关键帧以及相对位姿，并据此计算上一帧的位姿，并将其赋值给上一帧
								1.2 条件1：上一帧为关键帧；条件2：单目模式；条件3：IMU单目模式；条件4：SLAM模式；只要满足条件1~4中的任何一个，就结束
								1.3 计算上一帧中深度值为正的地图点，注意这里只有立体视觉的时候才会发生，也就是在构建Frame的时候会保存匹配的特征点的深度信息；如果没有深度值大于0的点，就直接结束，如果有的话，就按照深度进行排序
								1.4 对获取的有深度的点进行遍历，如果上一帧在这个索引下本身就有地图点，就不执行任何操作；如果没有地图点或者地图点的观测小于1，那么就在这里新建一个临时的地图点，用于增强跟踪；注意，只有在这个函数里面才会生成没有观测的地图点，而且这些地图点在后面条件满足的时候会被删除
								1.5 如果创建新的临时的地图点：获得地图点的世界系坐标，并新建一个地图点，将其添加到上一帧的地图点列表中，并添加到变量mlpTemporalPoints中，用于后面方便删除
								1.6 注意这里的nPoints有点歧义，不管新不新建，都会+1，这里应该是计量新建的地图点的数目
								1.7 如果深度值超过阈值，并且新建的地图点的数目超过100，那么直接结束
							
							2. 如果是IMU模式，并且当前帧的时间戳大于前一次重定位时间戳+mnFramesToResetIMU，那么就PredictStateIMU，否则，直接使用恒速模型计算当前帧的位姿
								2.1 PredictStateIMU：
									2.1.1 如果当前帧没有前一帧，直接返回false并结束
									2.1.2 如果地图更新了并且有上一个关键帧，那么基于上一个关键帧的预积分来推导当前帧的位姿，并更新当前帧的的零偏以及当前帧的mPredBias（实际上没有使用）
									2.1.3 如果地图没有更新，那么直接基于上一帧的预积分来推导当前帧的位姿，并更新当前帧的的零偏以及当前帧的mPredBias（实际上没有使用）
									2.1.4 如果地图更新了，那么会更新关键帧和地图点，此时使用基于关键帧的预积分来推导当前帧的位姿会更准确；否则的话，当前帧距离上一帧更近，基于上一帧的预积分来推导当前帧的位姿会更准确
									2.1.4 对mbMapUpdated的说明，mbMapUpdated发生在以下情况下
										1. 回环或者融合
										2. 局部建图线程的LocalBundleAdjustment
										3. IMU三阶段的初始化
							
							3. 利用上一帧，使用投影匹配构建当前帧的投影，在非单目情况下，会计算前进还是后退，以此获取金字塔区间
								3.1 以下可以这么理解，例如一个有一定面积的圆点，在某个尺度n下它是一个特征点
								3.2 当相机前进时，圆点的面积增大，在某个尺度m下它是一个特征点，由于面积增大，则需要在更高的尺度下才能检测出来
								3.3 当相机后退时，圆点的面积减小，在某个尺度m下它是一个特征点，由于面积减小，则需要在更低的尺度下才能检测出来

							4. 如果匹配的数目少于20，那么增大搜索半径，再一次执行投影匹配；如果匹配的数目还是少于20，IMU模式直接返回true，非IMU模式返回false

							5. 利用PoseOptimization优化当前帧的位姿，并根据BA记录的外点，删除错误的匹配，并统计成功匹配的数目nmatchesMap

							6. 如果是纯定位，mbVO=nmatchesMap<10，返回nmatchesMap>20；

							7. 如果是IMU模式直接返回true；否则，返回nmatchesMap>=10
					
					1.4 如果上面的跟踪都失败：
						1.4.1 条件1：IMU模式；条件2：当前帧的ID<=上一次重定位成功的帧的ID+mnFramesToResetIMU（一般与相机帧率相同），也就是表示重定位成功没过多久就又失败了；条件1和条件2都满足的时候，就mState=LOST，认为跟丢了。否则，执行1.4.2 
						1.4.2 当前地图中的关键帧数目超过10帧，执行mState=RECENTLY_LOST，也就是会利用其他信息继续跟踪，不认为跟丢了。并记录此时的时间戳信息mTimeStampLost，否则，执行1.4.3 
						1.4.3 mstate=lost，认为跟丢了
				
				2. mstate != OK:
					2.1 mstate=recently_lost:
						2.1.1 先设置bOK=true
						
						2.1.2 如果是IMU模式，否则执行2.1.3：
							1. 如果当前地图已经MU初始化，那么就执行PredictStateIMU：
							2. 否则，令bOK=false
							3. 如果当前帧的时间戳减去跟丢的时间戳mTimeStampLost的值大于time_recently_lost（5s），那么，mstate=lost，也就是尝试重建跟踪失败了，并且令bOK=false
						
						2.1.3 非IMU模式：
							1. bOK=Relocalization:
								1.1 计算当前帧的词袋

								1.2 利用DBOW计算当前帧的候选关键帧mpKeyFrameDB->DetectRelocalizationCandidates：
									1.2.1 记录与当前帧有相同单词的关键帧，如果为空，直接结束
									1.2.2 记录1.2.1中最大的单词数量，并令minCommonWords=maxCommonWords*0.8f为阈值，过滤单词数量在此之下的关键帧，并计算满足条件的关键帧与当前帧的得分mRelocScore
									1.2.3 获取1.2.2中满足条件的关键帧的最好的10帧共视关键帧，计算这些共视关键帧中与当前帧有相同单词的关键帧与当前帧的分数mRelocScore以及累计得分，并标记最优得分及其对应的关键帧，注意此处有一些问题，因为，这里并没有重新计算得分，而是直接从mRelocScore中获取，而这个mRelocScore并不一定是1.2.2中计算的，而是之前进入这个函数的时候计算的
									1.2.4 以minScoreToRetain=0.75f*bestAccScore为阈值根据累计得分进行筛选，并将1.2.3中最有得分对应的关键帧添加到候选关键帧之中

								1.3 对获取的每一帧候选关键帧，与当前帧构建匹配，使用词袋进行匹配，如果匹配的数量不少于15，那么构建MLPnP求解器，然后迭代求解，如果求解得到Tcw，那么设置当前帧的位姿，并将内点赋值给当前帧的地图点，然后使用PoseOptimization优化位姿，并计算内点数量，如果数量少于10个，就是用下一个MLPnP重新求解；否则，使用BA的外点结果更新当前帧的地图点mvpMapPoints；如果BA内点的数量超过50，那么不在进行MLPnP求解，并结束；否则，利用BA优化后的位姿，重新进行投影匹配，如果内点+投影匹配增加的匹配少于50，那么用下一个MLPnP重新求解；否则，再次执行PoseOptimization优化位姿，如果内点数量不超过30，那么用下一个MLPnP重新求解，如果内点数量超过50，那么认为求解成功并结束；否则，用更小的窗口，更严格的描述子阈值重新进行投影匹配，如果内点+增加的内点数目>=50，那么再次进行PoseOptimization，并根据BA的结果，剔除mvpMapPoints中的外点
							2. 如果重定位失败，并且当前帧的时间戳-跟丢的时间戳mTimeStampLost的值大于3s，那么认为跟丢了，mstate=lost，bOK=false
					
					2.2 mstate=lost:
						2.2.1 如果当前地图中的关键帧数目少于10帧，那么ResetActiveMap，也就是对这少量的几个关键帧不保存，否则
						2.2.2 CreateMapInAtlas，保存当前地图，并新建一个新地图
						2.2.3 将mpLastKeyFrame赋空

			5.7.2 仅定位模式：此模式不运行局部建图线程和回环线程
				1. mstate=lost，那么执行重定位Relocalization

				2. mstate!=lost：
					2.1 如果mbVO=false，此时表明此帧（代码里面的函数应该是上一帧）匹配了很多的地图点，跟踪很正常；否则，匹配少于10个
						2.1.1 如果有速度，那么使用恒速模型跟踪当前帧
						2.1.2 否则，使用参考关键帧跟踪当前帧
					2.2 mbVO=true：
						2.2.1 如果有速度，使用恒速模型跟踪当前帧，并记录当前帧的地图点、外点、位姿
						2.2.2 使用Relocalization，并记录是否重定位成功
						2.2.3 如果恒速模型成功且重定位失败，那么将恒速模型跟踪的结果赋值为但前帧；注意这里运行了恒速模型跟踪，那么mbVO的值会被更新；如果mbVO依然为true，那么对非外点的地图点的nFound+1
						2.2.4 如果重定位成功，那么将mbVO赋值为false，认为此时跟踪的还不错；此时，不管恒速模型跟踪是否成功，也就是更相信重定位
						2.2.5 令bOK=bOKReloc||bOKMM

			5.7.3 如果当前帧没有参考关键帧，那么就将track记录的参考关键帧赋值给它

			5.7.4 如果是正常的SLAM模式：
				1. 如果bOK=true，那么执行局部地图跟踪bOK=TrackLocalMap：
					1.1 UpdateLocalMap：更新局部关键帧 mvpLocalKeyFrames 和局部地图点 mvpLocalMapPoints
						1.1.1 UpdateLocalKeyFrames：更新局部关键帧
							1. 获取与当前帧有共视的所有关键帧（一级共视），并获得共视最多的关键帧，如果一级共视帧数量>80直接到4
							2. 获得每一个一级共视关键帧的前10帧共视关键帧，以及一级共视关键帧的父关键帧和子关键帧
							3. 将上面的一级共视关键帧和二级共视关键帧和父关键帧和子关键帧全部存储到局部关键帧中
							4. 将track和当前帧的参考关键帧设置为一级共视关键帧里面共视最多的关键帧
						1.1.2 UpdateLocalPoints：更新局部关键点。先把局部地图清空，然后将局部关键帧的有效地图点添加到局部地图中
							1. 清空局部地图点
							2. 添加局部关键帧中所有关键帧对应的所有非坏的地图点
					1.2 SearchLocalPoints：用局部地图点进行投影匹配，得到更多的匹配关系
						1.2.1 遍历当前帧的地图点，进行标记，在后面遍历所有的局部地图点的时候，碰到这里的地图点就跳过
						1.2.2 遍历局部地图点，判断地图点是否在当前帧的视野范围内，isInFrustum：依次经过以下判断
							1. 将这个地图点变换到当前帧的相机坐标系下，如果深度值为正才能继续下一步
							2. 将地图点投影到当前帧的像素坐标，如果在图像有效范围内才能继续下一步
							3. 计算地图点到相机中心的距离，如果在有效距离范围内才能继续下一步
							4. 计算当前相机指向地图点向量和地图点的平均观测方向夹角，小于60°才能进入下一步（实际上是挑选生成这个地图点的关键帧们左右接近的，而非对向或远离的）
							5. 根据地图点到光心的距离来预测一个尺度（仿照特征点金字塔层级）
							6. 记录相关信息
						1.2.3 记录在当前帧视野范围内的所有地图点，并计数，计数>0往下执行
						1.2.4 SearchByProjection：参数为某一帧和地图点；将局部地图点往当前帧上投影计算匹配
							1. 对每一个地图点，使用GetFeaturesInArea获取候选匹配信息，关于搜索半径r的计算为：
								已知当前相机指向地图点向量和地图点的平均观测方向夹角angle，如果angle<3.6°，那么r=2.5；否则r=4；当然和还需要乘以金字塔带来的尺度
							2. 候选特征点已经有三维点的跳过；获得与地图点匹配的最优和次优的特征点；如果最优匹配的距离小于阈值并且满足最优与次优的关系，就记录这匹配信息
							3. 注意这里没有直方图一致性检验
					1.3 如果IMU没有初始化，那么执行PoseOptimization优化当前帧的位姿
					1.4 如果mCurrentFrame.mnId<=mnLastRelocFrameId+mnFramesToResetIMU，那么执行PoseOptimization优化当前帧的位姿；初始化，重定位，重新开启一个地图都会使mnLastRelocFrameId变化
					1.5 如果mCurrentFrame.mnId>mnLastRelocFrameId+mnFramesToResetIMU
						1.5.1 如果地图没有更新，那么执行PoseInertialOptimizationLastFrame
						1.5.2 如果地图已经更新，那么执行PoseInertialOptimizationLastKeyFrame
						1.5.3 根据BA的结果，计算内点的数目，并只有在外点双目情形，才会将当前帧的地图点赋值为空；这说明了在局部地图跟踪中，不会轻易的将地图点赋值为空
						1.5.4 如果最近发生了重定位，并且内点数目少于阈值，那么认为局部地图跟踪失败
						1.5.5 如果是recent_lost并且内点数目>10，那么直接返回true
						1.5.6 如果是单目IMU模式：条件1：内点数目少于15，并且IMU已经第一阶段初始化；条件2：内点数目少于50并且IMU没有初始化；如果条件1或者条件2满足，那么返回false，否则，返回true
						1.5.7 如果不是单目IMU模式，而是双目IMU模式或者RGBD的IMU模式：如果内点数目<15就返回false，否则返回true
						1.5.8 如果不是1.5.6也不是1.5.7，那么：如果内点数目<30，返回false，否则返回true

				2. 如果bOK=false，那么认为局部建图跟踪失败

			5.7.5 如果是定位模式；
				1. 如果bOK=true并且mvVO=false，也就是跟上了，并且跟踪的还不错，那么执行局部建图跟踪bOK=TrackLocalMap

			5.7.6 讨论到目前为止bOK的状态变化：
		        bOK的历史变化---上一帧跟踪成功---当前帧跟踪成功---局部地图跟踪成功---true                -->OK   1 跟踪局部地图成功
		                 \               \              \---局部地图跟踪失败---false
		                  \               \---当前帧跟踪失败---false
		                   \---上一帧跟踪失败---重定位成功---局部地图跟踪成功---true                  -->OK  2 重定位
		                                 \           \---局部地图跟踪失败---false
		                                  \---重定位失败---false

		    5.7.7 讨论到目前为止的mstate的状态变化：
		    	mState的历史变化---上一帧跟踪成功---当前帧跟踪成功---局部地图跟踪成功---OK               -->OK  1 跟踪局部地图成功
		                   \               \              \---局部地图跟踪失败---OK               -->OK  3 正常跟踪
		                    \               \---当前帧跟踪失败---非OK 
		                     \---上一帧跟踪失败---重定位成功---局部地图跟踪成功---非OK
		                                   \           \---局部地图跟踪失败---非OK
		                                    \---重定位失败---非OK（传不到这里，因为直接return了）

			5.7.6 如果bOK=true，那么令mstate=OK，认为跟踪成功，否则执行5.7.7

			5.7.7 如果bOK=false且mstate=OK，此时第一阶段跟踪成功，第二阶段局部地图跟踪失败
				1. 如果是IMU模式：如果当前地图没有第一阶段初始化或者没有第三阶段初始化，那么重置地图ResetActiveMap；并mstate=recent_lost
				2. 如果不是IMU模式：mstate=recent_lost（从逻辑上讲，这里是lost更合适）
				3. 记录跟丢的时间mTimeStampLost为当前帧的时间戳

			5.7.8 条件1：当前帧ID<上一次重定位的时间戳+mnFramesToResetIMU，也就是距离上一次跟丢不远；条件2：当前帧ID>mnFramesToResetIMU，也就是已经经过了一些时间了；条件3：IMU模式；条件4：当前地图已经第一阶段初始化了；如果以上4个条件都满足，构建Frame变量pF=当前帧，并令pF的上一帧为track的上一帧mLastFrame，并对pF进行预积分（与当前帧一样）---pF并没有说使用，这个代码并没有作用

			5.7.9 如果当前地图已经第一阶段初始化：如果bOK=true
				1. 当前帧ID=上一次重定位的时间戳+mnFramesToResetIMU，也就是距离上一次跟丢不远，那么ResetFrameIMU（还没有实现）
				2. 当前帧ID！=上一次重定位的时间戳+mnFramesToResetIMU并且当前帧ID>上一次重定位的时间戳+30，那么mLastBias=mCurrentFrame.mImuBias，记录track的mLastBias变量

			5.7.10 更新显示等操作

			5.7.11 讨论到目前为止bOK的状态变化：
				bOK的历史变化---上一帧跟踪成功---当前帧跟踪成功---局部地图跟踪成功---true
		                 \               \              \---局部地图跟踪失败---false
		                  \               \---当前帧跟踪失败---false
		                   \---上一帧跟踪失败---重定位成功---局部地图跟踪成功---true
		                                 \           \---局部地图跟踪失败---false
		                                  \---重定位失败---false

        	5.7.12 讨论到目前为止的mstate的状态变化：
        		mState的历史变化---上一帧跟踪成功---当前帧跟踪成功---局部地图跟踪成功---OK
		                   \               \              \---局部地图跟踪失败---非OK（IMU时为RECENTLY_LOST）
		                    \               \---当前帧跟踪失败---非OK(地图超过10个关键帧时 RECENTLY_LOST)
		                     \---上一帧跟踪失败(RECENTLY_LOST)---重定位成功---局部地图跟踪成功---OK
		                      \                           \           \---局部地图跟踪失败---LOST
		                       \                           \---重定位失败---LOST（传不到这里，因为直接return了）
		                        \--上一帧跟踪失败(LOST)--LOST（传不到这里，因为直接return了）

		    5.7.13 如果跟踪成功或者最近才跟丢：
		    	1. Frame的mbIsSet，在Frame的SetPose方法中会将其赋值为true
		    	2. 如果上一帧的mbIsSet为true且当前帧的mbIsSet为true，那么计算速度mVelocity，也就是上一帧到当前帧的位姿变化Tcl，并令mbVelocity为true；否则，令mbVelocity为false
		    	3. 如果是IMU模式，使用当前帧的位姿给mpMapDrawer->SetCurrentCameraPose
		    	4. 遍历当前帧的mvpMapPoints，如果地图点非空且观测<1，那么将mvbOutlier设为false，并令这个地图点为NULL
		    	5. 删除双目或者RGB模式下，在恒速模型里面新建的临时地图点mlpTemporalPoints，并清空mlpTemporalPoints
		    	6. 判断是否需要插入关键帧bNeedKF=NeedNewKeyFrame：
		    		6.1 如果是IMU模式，并且没有第一阶段初始化
		    			6.1.1 如果是单目IMU模式，并且当前帧的时间戳-上一关键帧的时间戳>=0.25，那么直接返回true，因为太远的话IMU预积分就不准了；否则
		    			6.1.2 如果是双目/RGBD的IMU模式，并且当前帧的时间戳-上一关键帧的时间戳>=0.25，那么直接返回true，因为太远的话IMU预积分就不准了，起始可以直接与6.1.1写在一起；否则
		    			6.1.3 直接返回false
		    		6.2 如果是定位模式，直接返回false，也就是纯定位模式，不生成关键帧
		    		6.3 如果局部地图线程被停止，或者回环线程请求局部建图线程停止，那么直接返回false
		    		6.4 如果距离上一次重定位比较接近，并且Atlas中的关键帧的数据大于mMaxFrames，那么直接返回false
		    		6.5 计算地图点的最小观测次数nMinObs：如果Atlas中的关键帧的数目不超过2，则取2，否则，取3
		    		6.6 计算参考关键帧上的地图点的观测数目>=nMinObs的地图点的数目nRefMatches：TrackedMapPoints
		    		6.7 获取局部建图线程是否接受关键帧；在单目/单目IMU下，计算双目或RGB-D中成功跟踪的近点、双目或RGB-D中没有跟踪到的近点，并据此计算bNeedToInsertClose，这个变量表明跟踪的近点少，没有跟踪到的近点多，表明跟踪的不好，需要插入关键帧了
		    		6.8 计算阈值thRefRatio：如果只有一帧关键帧，则取0.4，否则，取0.75；如果是单目模式，取0.9；如果有mpCamera2，取0.75
		    		6.9 如果是单目IMU模式：如果mnMatchesInliers（在局部地图跟踪中计算的地图点匹配的数目）>350，那么，thRefRatio取值0.75，否则，取值0.9
		    		6.10 c1a：很久没有插入关键帧了；c1b：满足插入关键帧的最小时间间隔，并且localMapper处于空闲状态；c1c：在双目，RGB-D的情况下当前帧跟踪到的点比参考关键帧的0.25倍还少，或者满足bNeedToInsertClose；c2：和参考帧相比当前跟踪到的点太少 或者满足bNeedToInsertClose；同时跟踪到的内点还不能太少
		    		6.11 计算c3：初始化为false；在有上一关键帧的前提下，如果是单目IMU模式并且当前帧的时间戳-上一关键帧的时间戳>=0.5，那么c3=true；如果是不是单目IMU模式，且是双目IMU或者RGBD的IMU模式下，如果单目IMU模式并且当前帧的时间戳-上一关键帧的时间戳>=0.5，那么c3=true；
		    		6.12 计算c4：初始化为false；在单目IMU模式下，跟踪recent_lost或者跟踪的内点数目mnMatchesInliers在15~75之间，则c4=true，否则，c4=false
		    		6.13 在条件(((c1a||c1b||c1c) && c2)||c3 ||c4)下，执行如下，否则，直接返回false：
		    			6.13.1 如果局部建图线程空闲，或者局部建图线程正在做IMU初始化，则返回true；否则
		    			6.13.2 此时，局部建图线程不支持插入关键帧；先停掉局部线程的BA
		    			6.13.3 如果不是单目模式且不是单目IMU模式：如果局部建图的关键帧队列里的关键帧数目少于3，那么返回true；否则，返回false
		    			6.13.4 如果是单目模式或者是单目IMU模式，返回false

		    	7. 条件1：bNeedKF；条件2：bOK；条件3：mInsertKFsLost；条件4：mstate=recent_lost；条件5：IMU模式；如果条件1成立且（条件2成立或者（条件3、4、5都成立）），那么创建关键帧CreateNewKeyFrame
		    		7.1 如果局部建图线程正在初始化且没做完或关闭了,就无法插入关键帧，直接结束
		    		7.2 如果局部建图线程停止接受关键帧，直接结束
		    		7.3 将当前帧包装成关键帧
		    		7.4 如果IMU初始化已经完成，那么关键帧的bImu为true
		    		7.5 将当前帧的零偏赋值给关键帧；track的参考关键帧更新为这个关键帧，当前帧的参考关键帧指向这个关键帧
		    		7.6 如果有上一关键帧，那么这个关键帧的prevKF就是上一个关键帧，上一个关键帧的nextKF就是这个关键帧
		    		7.7 更新track的mpImuPreintegratedFromLastKF，预积分从这个关键帧开始
		    		7.8 如果不是单目模式且不是单目IMU模式：
		    			7.8.1 更新当前帧的R t Ow
		    			7.8.2 获取当前帧的有深度的特征点的集合vDepthIdx，并依赖深度值进行排序
		    			7.8.3 对vDepthIdx进行遍历：
		    				1. 如果特征点对应位置没有地图点，那么就创建一个地图点；如果有地图点，但是地图点的观测为0，那么先将地图点删除，然后创建一个地图点，创建的方法如下：
		    					1.1 通过特征点获得深度并反算出地图点的坐标，然后创建一个新的地图点，并添加观测为创建的这个关键帧，这个关键帧也添加这个地图点，当前帧的mvpMapPoints也会添加这个地图点；如果是在非左右目的双目模式下，还需要给当前帧的mvpMapPoints添加这个地图点，注意的是，这个地图点在mvpMapPoints中的index已经超过了左图像提取的特征点的数目N，同时，这个地图点还会再次添加这个关键帧，只是index不同了，这个关键帧也会再次添加这个地图点，只是index不同了
		    					1.2 这个地图点重新计算描述子、方向、深度阈值；Atlas添加这个地图点，并且nPoints递增
		    				2. 如果不创建地图点，那么nPoints就递增
		    				3. 如果深度大于阈值，并且nPoints也大于阈值，说明此时再创建的地图点已经不太准了，直接跳出循环
		    		7.9 将这个关键帧插入到局部建图线程中；插入好了，允许局部建图停止
		    		7.10 更新上一关键帧为这个关键帧，上一关键帧ID为当前帧的ID

		    	8. 遍历当前帧的地图点，如果地图点非空并且为外点，那么将其赋值为NULL
		    5.7.14 mstate=lost
		    	1. 如果当前活跃地图中的关键帧数目<=10，那么重置当前地图ResetActiveMap并结束
		    	2. 如果是IMU模式且当前地图还没有初始化，那么重置当前地图ResetActiveMap并结束
		    	3. 如果运行到此处，那么创建新地图CreateMapInAtlas并结束

		    5.7.15 如果当前帧没有参考关键帧，那么将当前track的参考关键帧赋值为当前关键帧的参考关键帧变量

		    5.7.16 设置上一帧为当前帧

		    5.7.17 讨论到目前为止的mstate的状态变化：
		    	mState的历史变化---上一帧跟踪成功---当前帧跟踪成功---局部地图跟踪成功---OK
			               \               \              \---局部地图跟踪失败---非OK（IMU时为RECENTLY_LOST）
			                \               \---当前帧跟踪失败---非OK(地图超过10个关键帧时 RECENTLY_LOST)
			                 \---上一帧跟踪失败(RECENTLY_LOST)---重定位成功---局部地图跟踪成功---OK
			                  \                           \           \---局部地图跟踪失败---LOST
			                   \                           \---重定位失败---LOST（传不到这里，因为直接return了）
			                    \--上一帧跟踪失败(LOST)--LOST（传不到这里，因为直接return了）

			5.7.18 如果mstate=OK或者mstate=recent_lost
				1. 如果当前帧的mbIsSet为true，那么计算当前帧的参考关键帧到当前帧的位姿，并保存到mlRelativeFramePoses，添加当前帧的参考关键帧到mlpReferences中，添加当前帧的时间戳到mlFrameTimes，添加当前帧是否是lost的信息到mlbLost中
				2. 如果当前帧的bIsSet为false，那么将mlRelativeFramePoses的back再次添加到mlRelativeFramePoses中，添加mlpReferences的back到mlpReferences中，添加mlFrameTimes的back到mlFrameTimes中，添加当前帧是否是lost的信息到mlbLost中

	6. 局部建图线程：
		6.1 大部分与ORB-SLAM2相同，相关函数可以参考ORB-SLAM2的笔记
		6.2 有关IMU初始化以及使用的方式可以

	7. 回环线程：
		7.1 创建新地图的标准
			7.1.1 当相机跟踪失败就开始重定位，如果过了一段时间重定位仍然失败，则将活跃地图标记为不活跃地图，存储在地图集合里。然后初始化一个新地图，评判跟踪丢失的标准：
			7.1.2 成功匹配的特征点的数量：当前帧和局部地图中成功匹配数量高于定义的阈值
			7.1.3 相机位姿的可观测性：如果检测到的点几何条件不好（如天空这样的远点），那么估计的相机也不准，相机位姿是不客观的；这种时候，位姿不准确的关键帧会被删除，地图覆盖的范围可能会减小，但是地图的精度将会显著上升。

		7.2 什么时候新建地图
			7.2.1 SLAM系统刚启动，席间地图集Atlas类的时候
			7.2.2 跟踪线程中时间戳异常的时候
			7.2.3 跟踪线程中跟踪丢失后：
				1. 如果是第一阶段跟踪丢失，当前活跃地图的处理方法：如果当前活跃地图中关键帧数量小于10个，认为该地图中有效信息太少，直接重置，丢弃当前地图；否则，该地图仍有一定价值，存储起来并新建一个地图
				2. 如果到第二阶段跟踪丢失，当前活跃地图的处理方法：如果当前是纯视觉模式且地图中关键帧超过5个或者IMU模式下已经完成IMU初始化，认为该地图仍有一定价值，存储起来并新建一个地图；否则重置，丢弃当前地图
		
		7.3 CheckNewKeyFrames(): 查看还有没有还没有处理的关键帧

		7.4 将上一关键帧的回环候选和合并候选关键帧容器清空

		7.5 检测共视区域：bFindedRegion=NewDetectCommonRegions：
			7.5.1 如果一开始就不做回环，就直接结束（mbActiveLC）

			7.5.2 取出缓存的候选关键帧中最早的关键帧为当前关键帧，并将其设置为不要删除，并设置mbCurrentPlaceRecognition为true，并获取当前关键帧的地图mpLastMap

			7.5.3 如果mpLastMap是惯性模式，但是还没有经过第三阶段的IMU初始化，那么直接将当前关键帧加入到关键帧数据库中，并设置可以删除，然后直接结束，返回false

			7.5.4 如果是在双目模式下，并且mpLastMap中的关键帧的数量少于5，那么直接将当前关键帧加入到关键帧数据库中，并设置可以删除，然后直接结束，返回false

			7.5.5 如果mpLastMap中关键帧的数量少于12，那么直接将当前关键帧加入到关键帧数据库中，并设置可以删除，然后直接结束，返回false

			7.5.6 如果mnLoopNumCoincidences>0，注意初始化的时候mnLoopNumCoincidences为0：
				1. 设置bCheckSpatial为true，
				2. 利用当前关键帧的位姿和mpLoopLastCurrentKF（注意，其在DetectCommonRegionsFromBoW中有可能会被赋值为上一次的当前关键帧，在这里其实就是上一关键帧了）关键帧的位姿计算位姿Tcl，并据此构建gScl，尺度为1；利用gScl和DetectCommonRegionsFromBoW中计算的sim3变换mg2oLoopSlw计算gScw
				3. bCommonRegion=DetectAndReffineSim3FromLastKF:参数为当前关键帧、mpLoopMatchedKF、gScw、numProjMatches记录匹配数量、mvpLoopMPs（表示上一次搜索的时候，回环帧的最好的10个共视关键帧的所有非空非bad的地图点）、vpMatchedMPs记录匹配的地图点
					3.1 FindMatchesByProjection获取匹配数量，如果匹配数量少于阈值nProjMatches则返回false，否则继续往后面执行
					3.2 根据gScw和gSwm计算gScm，执行OptimizeSim3优化gScm并获取内点数目，如果内殿数目少于阈值nProjOptMatches则返回false，否则继续往后面执行；这里有一个问题，nNumProjMatches>=numOptMatches必然成立，但是nProjOptMatches>nProjMatches不一定成立，这里的阈值设置有些矛盾，优化后的匹配只会更少
					3.3 这里应该有一个bug，代码里面使用的是mScw，实际上应该使用优化得到的gScm与gswm计算得到gScw
					3.4 使用新的gScw再次调用FindMatchesByProjection，获取匹配的数目nNumProjMatches，如果大于阈值nProjMatchesRep，则返回true，并将gScw更新为最新计算的gScw，否则返回false
				4. 如果bCommonRegion为true
					4.1 标记时序检验成功bLoopDetectedInKF=true，mnLoopNumCoincidences累加；设置mpLoopLastCurrentKF可以删除了，并更新mpLoopLastCurrentKF为当前关键帧；更新mg2oLoopSlw为DetectAndReffineSim3FromLastKF中计算的gScw；mvpLoopMatchedMPs记录匹配到的地图点，重置时序检验失败的次数mnLoopNumNotFound为0，并判断mbLoopDetected=mnLoopNumCoincidences>=3
				5. 如果bCommonRegion为false
					5.1 当前时序检验失败bLoopDetectedInKF为false，mnLoopNumNotFound递增，如果mnLoopNumNotFound大于等于2，那么重置一些信息：mpLoopLastCurrentKF和mpLoopMatchedKF设置为可以删除、mnLoopNumCoincidences和mnLoopNumNotFound重置为0，mvpLoopMatchedMPs和mvpLoopMPs清空

			7.5.7 如果mnMergeNumCoincidences>0，注意初始化的时候mnMergeNumCoincidences为0：
				1. 利用当前关键帧的位姿和mpMergeLastCurrentKF（注意，其在DetectCommonRegionsFromBoW中有可能会被赋值为上一次的当前关键帧，在这里其实就是上一关键帧了）关键帧的位姿计算位姿Tcl，并据此构建gScl，尺度为1；利用gScl和DetectCommonRegionsFromBoW中计算的sim3变换mg2oMergeSlw计算gScw
				3. bCommonRegion=DetectAndReffineSim3FromLastKF，同上
				4. 如果bCommonRegion为true
					4.1 标记时序检验成功bMergeDetectedInKF=true，mnMergeNumCoincidences累加；设置mpMergeLastCurrentKF可以删除了，并更新mpMergeLastCurrentKF为当前关键帧；更新mg2oMergeSlw为DetectAndReffineSim3FromLastKF中计算的gScw；mvpMergeMatchedMPs记录匹配到的地图点，并判断mbMergeDetected=mnMergeNumCoincidences>=3
				5. 如果bCommonRegion为false
					5.1 当前时序检验失败bMergeDetectedInKF为false且mbMergeDetected为false，mnMergeNumNotFound递增，如果mnMergeNumNotFound大于等于2，那么重置一些信息：mpMergeLastCurrentKF和mmpMergeMatchedKF设置为可以删除、mnMergeNumCoincidences和mnMergeNumNotFound重置为0，mvpMergeMatchedMPs和mvpMergeMPs清空

			7.5.8 如果mbLoopDetected为true或者mbMergeDetected为true；注意初始化的时候mbMergeDetected=mbLoopDetected=false
				1. 将当前帧添加到关键帧数据库中，然后直接结束，返回true，表示找到了共视
				2. 由于这里找到了共视，因此当前关键帧不会设置可以删除

			7.5.9 获取当前关键帧的共视关键帧GetVectorCovisibleKeyFrames，此句实际上没有使用

			7.5.10 如果bMergeDetectedInKF为false或者bLoopDetectedInKF为false，此时在关键帧数据库中获取最好的几个候选关键帧，并放到vpMergeBowCand（不同map）和vpLoopBowCand（同map），mpKeyFrameDB->DetectNBestCandidates：
				1. 获得与当前关键帧有相同单词的关键帧及相同的单词的数量；如果没有相同单词的关键帧，那么直接结束
				2. 获得相同单词数的最大值，并取minCommonWords=maxCommonWords*0.8f为阈值，筛选获取的关键帧；并计算筛选的关键帧与当前关键帧的得分；如果没有满足条件的关键帧，那么就直接结束
				3. 对每一个筛选的关键帧，设置累计得分accScore，并令初值为这个关键帧与当前关键帧的词袋得分，并获取其共视最好的10帧关键帧；对每一个关键帧，如果其与当前关键帧有相同单词，那么就计算这个关键帧与当前关键帧的词袋得分并累加到accScore上，并获取这些共视关键帧中与当前关键帧具有最大词袋得分的关键帧；将信息存储到lAccScoreAndMatch中，并对其按照得分进行排序
				4. 遍历lAccScoreAndMatch，将其添加到vpLoopCand和vpMergeCand中，标准在于候选关键帧与当前关键帧是否是一个地图；直到vpLoopCand和vpMergeCand的数量满足要求，或者lAccScoreAndMatch遍历结束；因此vpLoopCand和vpMergeCand并不一定能够获取到指定的nNumCandidates个

			7.5.11 如果bLoopDetectedInKF为false且vpLoopBowCand不为空，那么mbLoopDetected=DetectCommonRegionsFromBoW：
				1. 参数为：vpLoopBowCand候选的闭环关键帧、mpLoopMatchedKF记录找到的闭环关键帧、mpLoopLastCurrentKF当成功闭环的时候赋值为当前关键帧、mg2oLoopSlw计算sim3变换、mnLoopNumCoincidences几何检验通过的次数、mvpLoopMPs回环关键帧的20个共视关键帧的所有非空非bad的地图点、mvpLoopMatchedMPs表示mvpLoopMPs在当前关键帧的匹配情况
				2. 获取当前关键帧的连接关键帧spConnectedKeyFrames
				3. 对每一个候选关键帧：
					3.1 获取其指定数量的最优的共视关键帧，并添加这个候选关键帧到最前面vpCovKFi；判断vpCovKFi与spConnectedKeyFrames有没有交集，如果有的话，就直接到下一个候选关键帧，否则继续往后面执行，令pMostBoWMatchesKF为当前的候选关键帧（这里的逻辑可能不太对，应该是选择跟当前关键帧共视最多的关键帧赋值给pMostBoWMatchesKF）
					3.2 遍历共视关键帧vpCovKFi，计算其与当前关键帧的词袋匹配，并记录最优的词袋匹配对应的下标和匹配数量、匹配的地图点等
					3.3 获取所有的地图点到spMatchedMPi中，并记录匹配的地图点的数目numBoWMatches、将所有的匹配的信息添加到vpMatchedPoints和vpKeyFrameMatchedMP中，注意对vpMatchedPoints和vpKeyFrameMatchedMP而言，后面的信息有可能会覆盖前面的信息；如果numBoWMatches小于阈值nBoWMatches就直接进入到下一个候选关键帧，否则继续往后面执行
					3.4 首先给bFixedScale赋值，如果是IMU单目模式并且还没有经过第三阶段初始化，那么将bFixedScale设为false；构建sim3求解器，并迭代直到收敛，如果没有收敛，那么直接进入到下一个候选关键帧，否则继续往后面执行
					3.5 清空vpCovKFi，并重新计算pMostBoWMatchesKF的指定数量的最优的连接关键帧，并赋值给vpCovKFi，并添加pMostBoWMatchesKF到vpCovKFi中
					3.6 遍历vpCovKFi中的关键帧：获取每一帧对应的地图点到spMapPoints和vpMapPoints中，将地图点对应的关键帧添加到vpKeyFrames中
					3.7 获取前面sim3求解器求得的旋转、平移和尺度gScm，利用pMostBoWMatchesKF的位姿构建sim3的gSmw，注意其旋转平移为pMostBoWMatchesKF的位姿，尺度为1；通过gScm*gSmw计算gScw
					3.8 通过gScw将vpMapPoints中的地图点往当前关键帧进行投影匹配，获取投影的地图点和对应的关键帧；如果匹配的地图点的数量少于阈值nProjMatches，那么直接进入到下一个候选关键帧，否则继续往后面执行
					3.9 首先给bFixedScale赋值，如果是IMU单目模式并且还没有经过第三阶段初始化，那么将bFixedScale设为false；然后使用OptimizeSim3优化gScm，并计算此时的内点数量，如果数量少于阈值nSim3Inliers，那么直接进入到下一个候选关键帧，否则继续往后面执行
					3.10 利用pMostBoWMatchesKF的位姿构建sim3的gSmw，注意其旋转平移为pMostBoWMatchesKF的位姿，尺度为1；通过gScm*gSmw计算gScw，通过gScm*gSmw计算gScw，注意这里的gScm是经过优化了的，再次通过gScw将vpMapPoints中的地图点往当前关键帧进行投影匹配，获取投影的地图点和对应的关键帧；如果匹配的地图点的数量numProjOptMatches少于阈值nProjMatches，那么直接进入到下一个候选关键帧，否则继续往后面执行
					3.11 获取当前关键帧指定数量的最优的共视关键帧并赋值到vpCurrentCovKFs中，遍历vpCurrentCovKFs开始进行几何校验：
						3.11.1 对每一个共视关键帧，根据其与当前关键帧的位姿计算Tjc，也就是当前关键帧到这个共视关键帧直接的变换；然后利用Tjc构建gSjc，尺度为1
						3.11.2 通过gSjc*gScw计算gSjw，注意gScw是通过gScm的改变来更新的
						3.11.3 执行几何校验函数DetectCommonRegionsFromLastKF：参数为共视关键帧、pMostBoWMatchesKF、gSjw、记录匹配数量numProjMatches_j、vpMapPoints、记录匹配的地图点vpMatchedMPs_j
							1. 设置set<MapPoint*> spAlreadyMatchedMPs(vpMatchedMPs.begin(), vpMatchedMPs.end())
							2. 执行FindMatchesByProjection获得匹配的数量：pCurrentKF, pMatchedKF, gScw, spAlreadyMatchedMPs, vpMPs, vpMatchedMPs，注意这里的pCurrentKF并不是上面的当前关键帧
								2.1 获取pMatchedKFw的指定数量的最优的共视关键帧到vpCovKFm中，并将pMatchedKFw也添加到vpCovKFm中，并构建set容器spCheckKFs(vpCovKFm.begin(),vpCovKFm.end())
								2.2 获取pCurrentKF的所有的连接关键帧到spCurrentCovisbles中
								2.3 如果vpCovKFm的size小于阈值nNumCovisibles，那么扩展vpCovKFm的规模，方法是获取vpCovKFm中关键帧的指定数量的最优的共视关键帧，并将其添加到vpCovKFm中
								2.4 遍历vpCovKFm获取其所有的地图点，添加到spMapPoints和vpMapPoints中
								2.5 通过将vpMapPoints中的地图点使用mScw往pCurrentKF中投影获取匹配，并记录匹配数量
							3. 如果匹配的数量少于阈值nProjMatches，则返回false；否则，返回true；
					3.12 如果numProjOptMatches大于nBestMatchesReproj（初值为0），那么更新nBestMatchesReproj、nBestNumCoindicendes、pBestMatchedKF、g2oBestScw、vpBestMapPoints和vpBestMatchedMapPoints
				4. 如果nBestMatchesReproj大于0，那么更新pLastCurrentKF、nNumCoincidences、pMatchedKF2并设置其不可删除、g2oScw、vpMPs、vpMatchedMPs，并返回nNumCoincidences >= 3
				5. 如果nBestMatchesReproj不大于0，那么返回false

			7.5.12 如果bMergeDetectedInKF为false且vpMergeBowCand不为空，那么mbMergeDetected=DetectCommonRegionsFromBoW
				1. 参数为：vpMergeBowCand候选的合并关键帧、mpMergeMatchedKF记录找到的合并关键帧、mpMergeLastCurrentKF当成功合并的时候赋值为当前关键帧、mg2oMergeSlw计算sim3变换、mnMergeNumCoincidences几何检验通过的次数、mvpMergeMPs合并关键帧的20个共视关键帧的所有非空非bad的地图点、mvpMergeMatchedMPs表示mvpLoopMPs在当前关键帧的匹配情况

			7.5.13 将当前关键帧添加到关键帧数据库中；如果mbMergeDetected为true或者mbLoopDetected为true，就直接返回true

			7.5.14 设置当前关键帧可以删除；设置当前关键帧的mbCurrentPlaceRecognition为false

		7.6 如果bFindedRegion为true
			7.6.1 如果同时检测到回环和地图合并，那么只执行合并
			7.6.2 如果mbMergeDetected为true
				1. 如果是IMU模式并且还没有初始化，那么直接运行到5，否则运行2
				2. 计算当前关键帧的世界系w1到融合关键帧的世界系w2的变换，并赋值为mSold_new，计算的过程为gSw2m*gSmc*gScw1，其中gSw2m表示融合关键帧的位姿，gScw1表示当前关键帧的位姿，gSmc是根据相似变换并优化得到;如果当前关键帧的地图与融合关键帧对应的地图都是惯性模式：
					2.1 如果两个地图的尺度相差比较大，就放弃融合，输出两个地图就可以了，此时执行：mpMergeLastCurrentKF和mpMergeMatchedKF可以删除了，mnMergeNumCoincidences和mnMergeNumNotFound重置为0，mvpMergeMatchedMPs和mvpMergeMPs清空，mbMergeDetected设置为false，然后执行下一次循环，否则继续往后面执行
					2.2 如果处于单目IMU模式或者双目IMU模式，并且当前关键帧对应的地图已经执行了第二阶段的初始化了，那么获取mSold_new对应的轴角，并将pitch和roll都设置为0，并重新计算mSold_new（注意此时的尺度令为1了）；这样做的理由是两个地图的重力方向一致，那么两个地图的世界系的Z轴方向也是一致的，因此也就只有yaw角不同，他们的pitch和roll应该是一样的
				3. 如果是在IMU模式下，执行MergeLocal2：将旧的地图合并到当前关键帧的地图里面
					3.1 如果正在进行全局BA，那么就停止全局BA；局部建图线程暂停，等待局部建图线程停止；获取当前关键帧的地图pCurrentMap，获取合并关键帧的地图pMergeMap
					3.2 利用mSold_new的旋转平移构建位姿T_on；清空局部建图线程还没有处理的关键帧；如果mSold_new的尺度不是1，则bScaleVel为true，否则为false（我们知道，如果在单目IMU模式或者双目IMU模式，mSold_new的尺度会被更新为1，也就是此时认为两个地图尺度是一致的，不会更新当前地图的尺度），然后将当前关键帧对应的地图变换到融合关键帧对应的地图的世界系中，使用函数ApplyScaledRotation实现，此函数上面已经分析；使用UpdateFrameIMU将尺度和零偏更新到普通帧
					3.3 如果是IMU模式，并且还没有完成第三阶段初始化，对加速度零偏和陀螺仪零偏赋0，并使用InertialOptimization优化零偏，然后将零偏使用UpdateFrameIMU更新到普通帧中（注意在优化函数InertialOptimization中，关键帧的位姿的零偏已经更新了）；设置当前地图已经完成了全部三阶段的初始化
					3.4 将融合关键帧对应的地图中的关键帧和地图点合并到当前关键帧对应的地图中：
						3.4.1 获取融合关键帧的地图中的所有的关键帧和所有的地图点
						3.4.2 遍历关键帧，如果这个关键帧非空、不是bad、并且对应的地图是融合关键帧的地图，那么
							1 pKF->UpdateMap(pCurrentMap): 更改关键帧对应的地图
							2 pCurrentMap->AddKeyFrame(pKF)：
								2.1 如果mspKeyFrames为空，那么这个关键帧是第一个关键帧，设置mnInitKFid、mpKFinitial和mpKFlowerID
								2.2 在mspKeyFrames中插入这个关键帧，并更新最大的mnID和mpKFlowerID（最小的mnId对应的关键帧）
							3 pMergeMap->EraseKeyFrame(pKF)：
								3.1 从mspKeyFrames中删除这个关键帧
								3.2 更新mpKFlowerID
						3.4.3 遍历地图点，如果这个地图点非空、不是bad、并且对应的地图是融合关键帧的地图，那么
							1 pMP->UpdateMap(pCurrentMap)：更改地图点对应的地图即可
							2 pCurrentMap->AddMapPoint(pMP)：在地图的mspMapPoints中插入这个地图点即可
							3 pMergeMap->EraseMapPoint(pMP)：在地图的mspMapPoints中删除这个地图点即可
						3.4.4 此处可能有bug，没有将mergeMap设置为bad，后续不好删除
						3.4.5 获取当前关键帧对应的地图中所有的关键帧，然后遍历这些关键帧，根据其位姿构建g2oSiw，尺度为1，然后添加到NonCorrectedSim3中
					3.5 将融合关键帧的地图的生成树添加到当前关键帧的地图中：将融合关键帧的父亲设置为当前关键帧；获取融合关键帧的父亲、祖父...祖宗，然后将父→子修改为子→父，也就是逻辑上将父子之间的关系对调，这样就能保证一个孩子只有一个父亲了
					3.6 获取融合关键帧的局部窗口：获取融合关键帧及其共视关键帧，并最多只选择前6个关键帧添加到mvpMergeConnectedKFs中
					3.7 更新当前关键帧的连接关系，并获取当前关键帧的局部窗口：获取当前关键帧及其共视关键帧，并最多只选择前6个关键帧添加到vpCurrentConnectedKFs中
					3.8 获取mvpMergeConnectedKFs中关键帧的最多的1000个地图点添加到spMapPointMerge，然后copy到vpCheckFuseMapPoint中
					3.9 SearchAndFuse：参数为当前关键帧的窗口vpCurrentConnectedKFs、vpCheckFuseMapPoint中的地图点：
						3.9.1 遍历关键帧，对每一个关键帧根据其位姿构建Scw，尺度为1，然后执行matcher.Fuse：
							1 将地图点往关键帧进行投影获取匹配，如果特征点早已经有了地图点，就将其添加到vpReplacePoints，后续会进行替换；否则直接添加这个关键帧到这个地图点的观测中，并在这个关键帧的地图点中添加这个地图点
						3.9.2 遍历vpReplacePoints，并在满足条件的情况下执行替换pRep->Replace(pMP):也就是用pMP替换pRep，在这里是使用融合关键帧窗口中的地图点替换掉当前关键帧窗口中的地图点
							1 如果两个地图点的ID相同，那么直接结束，不用替换了，两个点是同一个点
							2 记录pRep的mObservations、mnVisible和mnFound，并清空mObservations
							3 遍历观测mObservations
								3.1 如果pMP不在关键帧的地图点中，那么这个关键帧替换观测的地图点，这个地图点的观测添加这个关键帧
								3.2 如果pMP在关键帧的地图点中，那就是一个特征点对应有两个地图点，这是不被允许的，这个时候删除这个关键帧对pRep的观测，也就是在地图点中删除pRef就可以了
							4 pMP的nFound和nVisible递增，pMP的描述子更新，地图删除pRep这个地图点

					3.10 遍历当前关键帧的窗口vpCurrentConnectedKFs，更新关键帧的连接关系；遍历合并关键帧的窗口mvpMergeConnectedKFs，更新关键帧的连接关系
					3.11 如果当前关键帧对应的地图里面的关键帧的数量少于10，那么释放局部建图线程Release，并直接结束：
						3.11.1 如果mbFinished为true，直接结束
						3.11.2 设置mbStopped和mbStopRequested为false
						3.11.3 释放mlNewKeyFrames中的关键帧指针；清空mlNewKeyFrames
					3.12 执行优化MergeInertialBA：参数为track的最近的关键帧、合并关键帧、bStopFlag（初值为false）、当前关键帧的地图、CorrectedSim3（当前还是空）
					3.13 释放局部建图线程Release

				4. 如果不是在IMU模式下，执行MergeLocal：将新的地图合并到旧的地图里面
					4.1 如果正在进行全局BA，那么就停止全局BA；局部建图线程暂停，等待局部建图线程停止；清空局部建图线程的关键帧；获取当前关键帧的地图pCurrentMap，获取合并关键帧的地图pMergeMap；更新当前关键帧的连接关系
					4.2 获取当前关键帧的窗口的关键帧spLocalWindowKFs：使用的循环获取指定数量的关键帧，避免关键帧的数量太少，并将这些关键帧的地图点全部添加到spLocalWindowMPs中
					4.3 与当前关键帧相同，获取融合关键帧的窗口的关键帧spMergeConnectedKFs以及这些关键帧对应的地图点spMapPointMerge，并将这些地图点copy到vpCheckFuseMapPoint中
					4.4 计算未矫正的位姿和已矫正的位姿：
						4.4.1 获取当前关键帧的位姿添加到vNonCorrectedSim3中，获取mg2oMergeScw添加到vCorrectedSim3中
						4.4.2 遍历当前关键帧窗口中的关键帧：
							1 如果这个关键帧就是当前关键帧，那么直接获取g2oCorrectedSiw=g2oCorrectedScw，否则
							2 获取这个关键帧的位姿添加到vNonCorrectedSim3中，计算当前关键帧到这个关键帧的位姿，再使用世界到当前关键帧的sim3位姿，计算世界到这个关键帧的sim3位姿g2oCorrectedSiw，并添加到vCorrectedSim3中
							3 将g2oCorrectedSiw的尺度赋值给这个关键帧的mfScale，去除g2oCorrectedSiw的尺度计算得到correctedTiw并将其赋值给这个关键帧的mTcwMerge
					4.5 遍历当前关键帧窗口中的地图点：
						5.1 如果地图点为空或者为bad，那么直接删除spLocalWindowMPs中的这个地图点
						5.2 如果这个地图点的参考关键帧不在vCorrectedSim3中，说明这个地图点不是由当前关键帧的窗口中的关键帧生成的，直接删除spLocalWindowMPs中的这个地图点，此时numPointsWithCorrection递增1
						5.3 获取地图点的参考关键帧对应的g2oCorrectedSwi和g2oNonCorrectedSiw，然后将这个地图点的世界系坐标按照pw→利用g2oNonCorrectedSiw投影到参考系下→利用g2oCorrectedSwi计算到融合关键帧的世界系下；地图点的方向也按照类似的思路进行更新
					4.6 遍历当前关键帧窗口中的关键帧：设置这个关键帧的mTcwBefMerge和mTwcBefMerge，将mTcwMerge设置为位姿；修改这个关键帧的地图，记录mnMergeCorrectedForKF，在融合关键帧的地图中添加这个关键帧，在当前关键帧的地图中删除这个关键帧
					4.7 遍历当前关键帧窗口中的地图点：设置世界系坐标为mPosMerge，设置normal为mNormalVectorMerge，设置地图为融合关键帧的地图，在融合关键帧的地图中添加这个地图点，在当前关键帧的地图中删除这个地图点
					4.8 在mpAtlas中记录融合关键帧的地图经过了更改，设置当前关键帧的地图为bad，融合关键帧的地图的修改次数递增1，并将其ID修改为当前关键帧的地图的ID
					4.9 类似MergeLocal2中的方式融合当前关键帧的地图和融合关键帧的地图的生成树；更新融合关键帧的连接关系
					4.10 SearchAndFuse：将vpCheckFuseMapPoint中的地图点往vCorrectedSim3中的关键帧进行投影构建匹配，并对匹配的地图点进行融合，思路与上面的同名函数类似
					4.11 对当前关键帧窗口的关键帧和融合关键帧窗口的关键帧都进行连接关系的更新；并将当前关键帧窗口中的关键帧copy到vpLocalCurrentWindowKFs中，将融合关键帧窗口中的关键帧copy到vpMergeConnectedKFs中，执行优化LocalBundleAdjustment（优化的是vpLocalCurrentWindowKFs，固定vpMergeConnectedKFs）；局部建图线程释放
					4.12 获取当前关键帧的地图中的所有关键帧vpCurrentMapKFs（这里已经不包括当前关键帧窗口中的关键帧了，因为他们的地图已经更改为融合关键帧的地图了）和当前关键帧的地图中所有的地图点vpCurrentMapMPs（这里也不包括当前关键帧窗口中的关键帧对应的地图点了，因为他们的地图已经更改为融合关键帧的地图了）：
					4.13 如果是单目模式：
						4.13.1 遍历vpCurrentMapKFs中的这些关键帧，依据这些关键帧与当前关键帧的相对位姿以及mg2oMergeScw更新这些关键帧的位姿，并记录每个关键帧的mfScale、mTcwBefMerge和mTwcBefMerge
						4.13.2 遍历vpCurrentMapMPs中的这些地图点，根据地图点的参考关键帧的位姿和矫正的位姿计算其新的世界系坐标，并更新UpdateNormalAndDepth
					4.14 请求局部建图线程停止并等待局部建图线程停止；
					4.15 如果不是单目模式：执行优化OptimizeEssentialGraph
					4.16 遍历vpCurrentMapKFs中的关键帧，对每一个关键帧更改其地图，在当前关键帧地图中删除这个关键帧，将这个关键帧添加到融合关键帧地图中；遍历vpCurrentMapMPs中的地图点，对每一个地图点更改其地图，在当前关键帧的地图中删除这个地图点，将这个地图点添加到融合关键帧的地图中
					4.17 释放局部建图线程mpLocalMapper->Release();
					4.18 当前关键帧添加融合边；融合关键帧添加融合边；当前关键帧的地图和融合关键帧的地图的改变次数都递增1；mpAtlas删除坏的地图

				5. 记录当前关键帧的时间戳到vdPR_CurrentTime中，记录融合关键帧的时间戳到vdPR_MatchedTime中，并记录位置识别的结果到vnPR_TypeRecogn中；mpMergeLastCurrentKF和mpMergeMatchedKF可以删除了，mnMergeNumCoincidences和mnMergeNumNotFound重置为0，mvpMergeMatchedMPs和mvpMergeMPs清空，mbMergeDetected设置为false

				6. 如果此时还检测到回环，设置mpLoopLastCurrentKF和mpLoopMatchedKF可以删除，mnLoopNumCoincidences和mnLoopNumNotFound重置为0，mvpLoopMatchedMPs和mvpLoopMPs清空，mbLoopDetected为false；也就是在当前关键帧既检测到融合又检测到回环的时候，只执行融合，不执行回环


			7.6.3 如果mbLoopDetected为true
				1. 记录当前关键帧的时间戳到vdPR_CurrentTime中，记录闭环关键帧的时间戳到vdPR_MatchedTime，并记录位置识别的结果到vnPR_TypeRecogn中；更新mg2oLoopScw=mg2oLoopSlw；
				2. 如果当前关键帧的地图是惯性模式，那么：
					2.1 计算闭环关键帧对应的世界系到当前关键帧对应的世界系之间的变换g2oSww_new（闭环关键帧的世界到当前关键帧的世界），计算方法类似于地图合并中的计算，利用了回环关键帧到当前关键帧之间的相似变换
					2.2 计算g2oSww_new中的旋转对应的轴角，如果pitch和roll很小，而yaw比较小的话，就继续执行以下，否则，跳到2.3
						2.2.1 此处的判断的合理性在于：尺度漂移在pitch和roll方向上计划没有，在yaw方向比较大；实际上，载体在运行的时候，由于重力的影响，yaw方向的运动自由度会远远大于pitch和roll方向，所以此处的判断是合理的
						2.2.2 如果当前关键帧的地图是惯性模式（此处的判断纯属多于，因为，外面的if语句已经判断了）：如果在IMU模式下，并且当前关键帧的地图已经经过了第三阶段初始化，那么令pitch和roll为0，也就是认为尺度漂移只可能发生在yaw上，这样做也是合理的，毕竟只有yaw方向的运动是不受重力制约的；
						2.2.3 利用新的重新计算g2oSww_new（注意此时的尺度令为1了）；并利用更新的g2oSww_new重新计算mg2oLoopScw（闭环关键帧的世界到当前关键帧）
					2.3 认为获取的回环很糟糕，并令bGoodLoop为false
				3. 如果bGoodLoop为true：
					3.1 mvpLoopMapPoints=mvpLoopMPs
					3.2 CorrectLoop：
						3.2.1 局部建图线程请求停止，并清空关键帧（实际上是处理完关键帧）；如果正在进行全局BA，那么就停止全局BA；局部建图线程暂停，等待局部建图线程停止；更新当前关键帧的连接关系
						3.2.2 获取当前关键帧及其共视关键帧mvpCurrentConnectedKFs，并计算NonCorrectedSim3和CorrectedSim3，设置当前关键帧的位姿（使用CorrectedSim3中的位姿，并去除尺度）；遍历mvpCurrentConnectedKFs，计算CorrectedSim3和NonCorrectedSim3，并设置关键帧的位姿（使用CorrectedSim3中的位姿，并去除尺度）；遍历CorrectedSim3，并获取其键值对的关键帧，然后获取每一个关键帧的地图点，然后矫正这些地图点的世界系坐标和UpdateNormalAndDepth；如果是IMU模式，那么更新关键帧的速度（注意这里只是将其变换到回环关键帧的世界系下，没有更新尺度）；更新关键帧的连接关系
						3.2.3 当前关键帧对应的地图的变化次数递增1；检查当前关键帧的地图点与回环关键帧的地图点是否有冲突：如果同一个特征点对应有两个地图点，那么就用回环关键帧的地图点替换掉当前关键帧的地图点，如果没有冲突，那么就在当前关键帧中添加回环关键帧对应的地图点，并对这个地图点添加当前关键帧的观测并重新计算描述子
						3.2.4 SearchAndFuse：参数为CorrectedSim3和mvpLoopMapPoints，逻辑与上面的同名函数基本相同
						3.2.5 存储因为闭环地图点调整而新生成的连接关系LoopConnections：
							1. 遍历mvpCurrentConnectedKFs，获取每个关键这的共视关键帧（此时还没有更新连接关系），更新这个关键帧的连接关系，记录这个关键帧的连接关键帧信息到LoopConnections中
							2. 遍历这个关键帧的共视关键帧，并从LoopConnections中将其删除
							3. 遍历mvpCurrentConnectedKFs，并从LoopConnections中将其删除
						3.2.6 如果是IMU单目模式并且没有经过第三阶段初始化，那么bFixedScale为false，否则bFixedScale=mbFixScale
						3.2.7 如果是IMU模式，并且已经经过了第一阶段初始化，那么执行OptimizeEssentialGraph4DoF；否则，执行OptimizeEssentialGraph
						3.2.8 mpAtlas记录产生了一次大的改变；回环关键帧记录回环边，当前关键帧记录回环边；
						3.2.9 条件1：当前关键帧的地图没有经过IMU初始化；条件2：当前关键帧的地图中的关键帧的数目少于200并且mpAtlas中只有一个地图，那么，mbRunningGBA为true，mbFinishedGBA为false，mbStopGBA为false，mnCorrectionGBA=mnNumCorrection，并执行线程mpThreadGBA，其中执行函数RunGlobalBundleAdjustment
							1. 如果没有经过IMU第一阶段的初始化，那么执行GlobalBundleAdjustemnt，否则执行FullInertialBA
							2. 如果mbStopGBA为false：
								2.1 请求局部建图线程停止，并sleep到局部建图线程停止
								2.2 使用树结构遍历所有的关键帧，对于某个关键帧pKF而言，获取其子关键帧；如果这个关键帧没有经过优化，那么利用父关键帧的mTcwGBA记录（不是更新，子关键帧也会有称为父关键帧的时候，那时候会更新相关信息）子关键帧的位姿，并更新子关键帧的速度、零偏
								2.3 更新pKF的位姿，如果是imu模式，那么更新其速度和零偏
								2.4 获取当前关键帧的地图中所有的地图点，如果地图经过了BA，那么世界设置其世界系坐标；否则，获取地图点的参考关键帧，并利用参考关键帧的更新前后的位姿计算新的世界系坐标并更新
								2.5 记录当前关键帧的地图发生了很大的改变，地图改变的次数递增；释放局部建图线程Release
							3. mbFinishedGBA和mbRunningGBA设置为true
						3.2.10 释放局部建图线程Release，mLastLoopKFid更新为当前关键帧的id 
					3.3 mnNumCorrection递增1

				4 设置mpLoopLastCurrentKF和mpLoopMatchedKF可以删除，mnLoopNumCoincidences和mnLoopNumNotFound重置为0，mvpLoopMatchedMPs和mvpLoopMPs清空，mbLoopDetected为false

		7.7 更新上一关键帧为当前关键帧

		7.8 ResetIfRequested:
			7.8.1如果mbResetRequested为true：清空mlpLoopKeyFrameQueue，mLastLoopKFid设置为0，mbResetRequested和mbResetActiveMapRequested为false
			7.8.2 如果mbResetRequested为false，并且mbResetActiveMapRequested为投入：
				1. 遍历mlpLoopKeyFrameQueue，如果某关键帧的地图是mpMapToReset，那么就将这一关键帧从mlpLoopKeyFrameQueue删除
				2. mLastLoopKFid设置为mpAtlas->GetLastInitKFid()，mbResetActiveMapRequested设置为false

		7.9 如果CheckFinish（返回mbFinishRequested）为true，就跳出循环，否则就sleep(5000)

		7.10 SetFinish: 设置mbFinished为true


	8. optimize:
		8.1 



git: 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



分辨率最好调到：640 * 480



后续重点查看一下：4自由度的本质图优化

零偏的初始值是0，之后帧的初值可以根据上一帧或者上一关键帧

Tracking::PreintegrateIMU


// 总结下都在什么时候地图更新，也就是mbMapUpdated为true
// 1. 回环或融合
// 2. 局部地图LocalBundleAdjustment
// 3. IMU三阶段的初始化


左右目的形式的相机类型为：Rectified，对应的数据集为KITTI


// 这里关注一下
// 1. 对于行列数一样的矩阵，Eigen::ComputeThinU | Eigen::ComputeThinV    与    Eigen::ComputeFullU | Eigen::ComputeFullV 一样
// 2. 对于行列数不同的矩阵，例如3*4 或者 4*3 矩阵只有3个奇异向量，计算的时候如果是Thin 那么得出的UV矩阵列数只能是3，如果是full那么就是4
// 3. thin会损失一部分数据，但是会加快计算，对于大型矩阵解算方程时，可以用thin加速得到结果



目前尚未明白的点：
	1. 计算avgW、avgA的目的是什么？
	2. 两个普通帧之间的IMU预积分是比较准的，应该时间间隔比较小；如果是两个关键帧之间的话，时间间隔比较长，还是直接使用IMU预积分来构建约束吗？
	3. point-pose约束构架的hessian是稀疏的，但是添加了IMU信息或者光心约束之后还是稀疏的吗？还能使用稀疏求解器吗？
	4. 在邱笑晨的文档中，并没有将零偏当做状态量进行状态递推，那么代码里面实现的时候是如何构建他们之间的协方差的？
	5. 由于更新的并不是零偏，而是零偏的增量，因此零偏是如何更新的，零偏更新后，是否使用一阶泰勒进行展开求解预积分的更新量，当然此时的零偏也已经同步更新了
	6. 单目+imu模式下可以较快的初始化地图，速度大于ORB2的单目初始化？速度提升来自于哪里？
	7. 当零偏更新之后，预计分量会根据一阶泰勒公式进行更新，对各状态量的导数（实际上应该根据零偏的变化同步更新）却没有同步更新（初始化的时候有可能重新预积分，之后就不会重新预积分了，认为零偏的波动很小）


代码尚存疑惑点：
	1. 在恒速模型中UpdateLastFrame函数中，仅仅在非SLAM模式的多目下生成临时地图点用于增强跟踪，在SLAM系统下不生成；


notes：
	1. 多目使用方式，在跟踪中并没有起到作用，仅仅在BA中产生作用
	2. 在跟踪线程判定为关键帧的时候，如果是多目，会根据多目创建的地图点添加到关键帧之中


	




1. 学习ORB-SLAM3中多相机的使用
	1.1 在构造Frame的时候：双目模式会做深度计算；非双目模式会做三角化获得在左相机的深度
	1.2 跟踪过程会根据立体视觉恢复出部分点，增强跟踪的稳定性（代码中只有在非SLAM模式下，才会执行，不太合理）
	1.3 在当前帧被判定为关键帧的时候，会添加双目重建出来但是没有跟踪到的地图点到地图中，并给其添加相应属性信息，从而利用了多目信息
	1.4 优化的过程中
		1.3.1 如果是纯视觉，使用uv = π(Trl * Tlw * Pw)，其中Trl为两个相机外参，优化过程中不变，优化变量为Tlw和Pw
		1.3.2 如果是VIO，优化的变量是Tbw，然后根据Tcb去计算每个相机的位姿，优化过程中不会优化Tcb和两个相机之间的外参Trl
		1.3.3 无论是纯视觉还是VIO，实际上都是构建一个枢纽帧。在纯视觉中，枢纽帧是左相机系；在VIO中，枢纽帧是IMU的body系；优化仅仅优化枢纽帧的位姿，不会优化枢纽帧与其他各帧之间的相对位姿




运行实例：
	1. 双目（非左右目）：
		./Examples/Stereo/stereo_euroc ./Vocabulary/ORBvoc.txt ./Examples/Stereo/EuRoC.yaml /home/xiongchao/studying/SLAM/VSLAM/ORB-SLAM/orb3/dataset/MH_01_easy ./Examples/Stereo/EuRoC_TimeStamps/MH01.txt dataset-MH01_stereo

	2. 双目（非左右目）+IMU：
		./Examples/Stereo-Inertial/stereo_inertial_euroc ./Vocabulary/ORBvoc.txt ./Examples/Stereo-Inertial/EuRoC.yaml /home/xiongchao/studying/SLAM/VSLAM/ORB-SLAM/orb3/dataset/MH_01_easy ./Examples/Stereo/EuRoC_TimeStamps/MH01.txt

		./Examples/Stereo-Inertial/stereo_inertial_tum_vi ./Vocabulary/ORBvoc.txt ./Examples/Stereo-Inertial/EuRoC.yaml /home/xiongchao/studying/SLAM/VSLAM/ORB-SLAM/orb3/dataset/MH_01_easy/mav0/cam0/data /home/xiongchao/studying/SLAM/VSLAM/ORB-SLAM/orb3/dataset/MH_01_easy/mav0/cam1/data ./Examples/Stereo-Inertial/EuRoC_TimeStamps/MH01.txt ./Examples/Stereo-Inertial/EuRoC_IMU/MH01.txt dataset-corridor1_512_stereoi
